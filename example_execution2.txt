range a b => (if (equals a b) [a ; nil] [a ; (range (add a 1) b)])
reduce f r => (if (not (second r)) (first r) (f (first r) (reduce f (second r))))
(reduce add (range 1 3))
    *A = add
    *B = (range 1 3)
    (if (not (second *B)) (first *B) (*A (first *B) (reduce *A (second *B))))
        (not (second *B))
            (second *B)
                *B, 2
                    (range 1 3), 2
                        *C = 1
                        *D = 3
                        (if (equals *C *D) [*C ; nil] [*C ; (range (add *C 1) *D)]), 2
                            (equals *C *D)
                                *C
                                    1
                                        ret 1
                                    ret 1
                                *D
                                    3
                                        ret 3
                                    ret 3
                                ret (1 == 3) = 0
                            [*C ; (range (add *C 1) *D)], 2
                                (range (add *C 1) *D)
                                    *E = (add *C 1)
                                    (if (equals *E *D) [*E ; nil] [*E ; (range (add *E 1) *D)])
                                        (equals *E *D)
                                            *E
                                                (add *C 1)
                                                    *C
                                                        1
                                                            ret 1
                                                        ret 1
                                                    1
                                                        ret 1
                                                    ret (1 + 1) = 2
                                                ret 2
                                            *D
                                                ret 3
                                            ret (2 == 3) = 0
                                        [*E ; (range (add *E 1) *D)]
                                            *F = (range (add *E 1) *D)
                                            ret [*E, *F]
                                        ret [*E, *F]
                                    ret [*E, *F]
                                ret [*E, *F]
                            ret [*E, *F]
                        ret [*E, *F]
                    ret [*E, *F]
                ret [*E, *F]
            ret (![*E, *F]) = 0
        (*A (first *B) (reduce *A (second *B)))
            *A
                add
                    ret add
                ret add
            (add (first *B) (reduce *A (second *B)))
                (first *B)
                    *B, 1
                        (range 1 3), 1
                            *G = 1
                            *H = 3
                            (if (equals *G *H) [*G ; nil] [*G ; (range (add *G 1) *H)]), 1
                                (equals *G *H)
                                    *G
                                        1
                                            ret 1
                                        ret 1
                                    *H
                                        3
                                            ret 3
                                        ret 3
                                    ret (1 == 3) = 0
                                [*G ; (range (add *G 1) *H)], 1
                                    *G
                                        ret 1
                                    ret 1
                                ret 1
                            ret 1
                        ret 1
                    ret 1
                (reduce *A (second *B))
                    *I = (second *B)
                    (if (not (second *I)) (first *I) (*A (first *I) (reduce *A (second *I))))
                        (not (second *I))
                            (second *I)
                                *I, 2
                                    (second *B), 2
                                        *B, 2, 2
                                            *B, 2, 2
                                                (range 1 3), 2, 2
                                                    *J = 1
                                                    *K = 3
                                                    (if (equals *J *K) [*J ; nil] [*J ; (range (add *J 1) *K)]), 2, 2
                                                        (equals *J *K)
                                                            *J
                                                                ret 1
                                                            *K
                                                                ret 3
                                                            ret (1 == 3) = 0
                                                        [*J ; (range (add *J 1) *K)], 2, 2
                                                            (range (add *J 1) *K), 2
                                                                (if (equals a b) [a ; nil] [a ; (range (add a 1) b)])
