An interpreted lisp-like functional programming language with lazy evaluation and memoization.

I set out to make a programming language, and this is what I ended up with.

## roadmap:
> efficiency:
[ ] do 10000 executions in <1s
[ ] do 100000 executions in <1s
[ ] do 1000000 executions in <1s
> features:
[ ] implement memoization
[ ] implement lazy/eager data pairs
[ ] read integer
[ ] hello world program
[ ] simple garbage collector
[ ] add multi-threaded support
[ ] stop using recursion (instead, use a stack/queue)
[ ] add comment support
[ ] pre-processes base expressions in parsing
> bugs:
[ ] get rid of memory leaks
