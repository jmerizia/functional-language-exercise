An interpreted lisp-like functional programming language with lazy evaluation and memoization.

I set out to make a programming language, and this is what I ended up with.

## roadmap:

> efficiency:

- [x] do 1000 executions in <1s
- [ ] do 10000 executions in <1s
- [ ] do 100000 executions in <1s
- [ ] do 1000000 executions in <1s

> features:

- [ ] implement memoization
- [ ] implement lazy/eager data pairs
- [ ] read integer
- [ ] hello world program
- [ ] simple garbage collector
- [ ] add multi-threaded support
- [ ] stop using recursion (instead, use a stack/queue)
- [ ] add comment support
- [ ] pre-processes base expressions in parsing
- [ ] compile in WASM and embed on a website
- [ ] add types?
- [ ] add string shorthand

> bugs:

- [ ] get rid of memory leaks
