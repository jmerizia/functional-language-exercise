The centerpoint of this language are the constructs:
- Data Pair [(), ()]
    Lazy evaluation on both items.
- Execution Pair {(), ()}
    Multi-threaded and fast evaluation of both items.

The Data Pair will execute both sides (unless given a specific side) in series.
The Parallel Pair will execute in parallel (returning only once both values return).
Thus with data pairs, there is a guarantee on which will execute first, 
but this is not so for Parallel Pairs.

This allows for some interesting results:

-- url_ is a list of urls
scrape url_ => { (get_request (first url_)) , (if (second url_) (scrape (second url_)) (nil)) }

The scrape function will consume a list of url's, and then produce a list of the request results,
all done in parallel! Note that scrape will not return until all requests are completed.

Here is a generalized parallel map:

-- L is a list, and F is a function to evaluate over all items
map L F => { (F (first L)) , (if (second L) (map (second L) F) (nil)) }

The equalivalent sequential map is just:

map L F => [ (F (first L)) , (if (second L) (map (second L) F) (nil)) ]

replacing '{}' braces for '[]' brackets. Neato!
